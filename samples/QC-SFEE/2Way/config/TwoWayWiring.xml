<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd">

	<description><![CDATA[
  Simple test wiring to write out the first generic artifact!
  ]]></description>

	<bean class="org.openadaptor.core.jmx.MBeanServer">
		<description>
			Embed this in your config to expose jmx interface via http
			and rmi.
		</description>
		<constructor-arg value="8082" />
	</bean>

	<bean id="SystemUtil" class="org.openadaptor.util.SystemUtil">
		<description>
			Embed this in your config to expose useful management bean.
		</description>
	</bean>

	<bean id="LogAdmin"
		class="org.openadaptor.thirdparty.log4j.LogAdmin">
		<description>
			Embed this in your config to expose log4j management.
		</description>
	</bean>
	<bean id="SystemPropertyConfigurer"
		class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<property name="ignoreResourceNotFound" value="false" />
		<property name="systemPropertiesMode">
			<bean
				id="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer.SYSTEM_PROPERTIES_MODE_OVERRIDE"
				class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />
		</property>
		<property name="locations">
			<description>
				Properties set by a file in list below are supposedly
				overridden by settings in a file later in list below.
			</description>
			<list>
				<value>classpath:ccf.properties</value>
				<value>classpath:qc.properties</value>
				<value>classpath:sfee.properties</value>
			</list>
		</property>
	</bean>
	<bean id="Adaptor" class="org.openadaptor.core.adaptor.Adaptor">
		<property name="messageProcessor" ref="Router" />
	</bean>

	<bean id="Router" class="org.openadaptor.core.router.Router">

		<property name="processMap">
			<map>

				<entry key-ref="QC2SFEESynchronizationStatusPollingReader"
					value-ref="QCReader" />
				<entry key-ref="QCReader" value-ref="SFEETransformer" />
				<entry key-ref="SFEETransformer"
					value-ref="SFEEEntityService" />
				<entry key-ref="SFEEEntityService"
					value-ref="SFEEWriter" />
				<entry key-ref="SFEEWriter"
					value-ref="SynchronizationStatusAndIdentityMappingTableUpdater" />

				<entry key-ref="SFEE2QCSynchronizationStatusPollingReader"
					value-ref="SFEEReader" />
				<entry key-ref="SFEEReader" value-ref="QCTransformer" />
				<entry key-ref="QCTransformer"
					value-ref="QCEntityService" />
				<entry key-ref="QCEntityService" value-ref="QCWriter" />
				<entry key-ref="QCWriter" value-ref="SynchronizationStatusAndIdentityMappingTableUpdater" /> 
			</map>
		</property>
		<property name="exceptionProcessor" ref="ExceptionHandler" />
	</bean>
	
	<bean id="QC2SFEESynchronizationStatusPollingReader"
		class="com.collabnet.ccf.core.test.plugins.SimpleLoopingPollingReadConnector">
		<description>
			This polling connector polls the CCF database tables that contain the repository
			mapping and the synchronization info and feeds the details to the source repository
			reader piped down the line. Please refer the processMap configuration for the Router
			bean.
			
			In this case this polling reader reads the synchronization status using the database
			read connector configured in the property delegate.
			
			Polling interval seconds is configured as 0 to indicate that the polling reader should
			read from the database read connector continuously without and pauses in between.
		</description>
		<property name="pollLimit" value="-1" />
		<property name="delegate" ref="QC2SFEESynchronizationStatusPollingReaderJdbcConnection" />
		<property name="pollIntervalSecs" value="0" />
	</bean>
	
	<bean id="SFEE2QCSynchronizationStatusPollingReader"
		class="com.collabnet.ccf.core.test.plugins.SimpleLoopingPollingReadConnector">
		<description>
			This polling connector polls the CCF database tables that contain the repository
			mapping and the synchronization info and feeds the details to the source repository
			reader piped down the line. Please refer the processMap configuration for the Router
			bean.
			
			In this case this polling reader reads the synchronization status using the database
			read connector configured in the property delegate.
			
			Polling interval seconds is configured as 0 to indicate that the polling reader should
			read from the database read connector continuously without and pauses in between.
		</description>
		<property name="pollLimit" value="-1" />
		<property name="delegate" ref="SFEE2QCSynchronizationStatusPollingReaderJdbcConnection" />
		<property name="pollIntervalSecs" value="0" />
	</bean>
	
	<bean id="QC2SFEESynchronizationStatusPollingReaderJdbcConnection"
		class="org.openadaptor.auxil.connector.jdbc.reader.JDBCReadConnector">
		<description>
			This is the JDBC read connector used by the SynchronizationStatusPollingReader to read the
			repository mapping and the synchronization info.
		</description>
		<property name="jdbcConnection" ref="JdbcConnectionReadQC2SFEE" />
		<!-- batch size of 0 or less means process all rows in one message batch. -->
		<!-- batch size of one means process one row per message and so on -->
		<property name="batchSize" value="1" />
		<property name="resultSetConverter" ref="ResultSetConverter" />
		<property name="sql">
			<value>${ccf.qcreader.poller.sql}</value>
		</property>
	</bean>
	
	<bean id="SFEE2QCSynchronizationStatusPollingReaderJdbcConnection"
		class="org.openadaptor.auxil.connector.jdbc.reader.JDBCReadConnector">
		<description>
			This is the JDBC read connector used by the SynchronizationStatusPollingReader to read the
			repository mapping and the synchronization info.
		</description>
		<property name="jdbcConnection" ref="JdbcConnectionReadSFEE2QC" />
		<!-- batch size of 0 or less means process all rows in one message batch. -->
		<!-- batch size of one means process one row per message and so on -->
		<property name="batchSize" value="1" />
		<property name="resultSetConverter" ref="ResultSetConverter" />
		<property name="sql">
			<value>${ccf.sfeereader.poller.sql}</value>
		</property>
	</bean>
	<bean id="SFEETransformer"
		class="com.collabnet.ccf.core.transformer.XsltProcessor">
		<description>The xsltDir specifies the directory in which the xsl files are contained. The naming conventions
		for the xsl files need to be followed. 
		Name of an xsl file should be: sourceSystem+sourceRepository+targetSystem+targetRepository.xsl 
		</description>
		<!--  <property name="xsltFile" value="${ccf.qc2sfee.xsltFile}" /> -->
		<property name="xsltDir" value="${ccf.xsltDir}" />
	</bean>
	<bean id="QCReader" class="com.collabnet.ccf.pi.qc.v90.QCReader">
		<description>Reads the modified defects from QC</description>
		<property name="serverUrl" value="${qc.system.1.url}" />
		<property name="userName" value="${qc.system.1.username}" />
		<property name="password" value="${qc.system.1.password}" />
		<property name="connectionManager" ref="QCConnectionManager"></property>
		<property name="sleepInterval" value="100"></property>
	</bean>
	<bean id="QCConnectionManager"
		class="com.collabnet.ccf.core.eis.connection.ConnectionManager">
		<property name="maxConnectionsPerPool" value="5"></property>
		<property name="maxIdleTimeForConnection" value="600000" />
		<property name="scavengerInterval" value="120000"></property>
		<property name="connectionFactory" ref="QCConnectionFactory"></property>
	</bean>
	<bean id="QCConnectionFactory"
		class="com.collabnet.ccf.pi.qc.v90.QCConnectionFactory">
	</bean>

	<bean id="SFEEReader"
		class="com.collabnet.ccf.pi.sfee.v44.SFEEReader">
		<description>Reads the modified defects from SFEE</description>
		<property name="username" value="${sfee.server.1.username}" />
		<property name="password" value="${sfee.server.1.password}" />
		<property name="serverUrl"
			value="${sfee.server.1.url}" />
		<property name="connectionManager" ref="SFEEConnectionManager"></property>
		<property name="sleepInterval" value="100"></property>
	</bean>
	<bean id="SFEEConnectionManager"
		class="com.collabnet.ccf.core.eis.connection.ConnectionManager">
		<property name="maxConnectionsPerPool" value="5"></property>
		<property name="maxIdleTimeForConnection" value="600000" />
		<property name="scavengerInterval" value="120000"></property>
		<property name="connectionFactory" ref="SFEEConnectionFactory"></property>
	</bean>
	<bean id="SFEEConnectionFactory"
		class="com.collabnet.ccf.pi.sfee.v44.SFEEConnectionFactory">
	</bean>
	<bean id="SFEEWriter"
		class="com.collabnet.ccf.pi.sfee.v44.SFEEWriter">
		<description>
			This data processor is responsible for writing the artifacts coming from the
			EntitySerive into the target SFEE system.
			It converts/extracts the data from the Generic Artifact XML and pushes to the
			target SFEE system.
		</description>
		<property name="username" value="${sfee.server.1.username}" />
		<property name="password" value="${sfee.server.1.password}" />
		<property name="serverUrl"
			value="${sfee.server.1.url}" />
		<property name="createToken" value="create" />
		<property name="updateComment"
			value="Synchronized by Connector user" />
		<property name="connectionManager" ref="SFEEConnectionManager"></property>
	</bean>
	<bean id="SFEEEntityService"
		class="com.collabnet.ccf.core.EntityService">
		<description>
			This component is responsible for determining if the current artifact that is being
			shipped is to be created or updated in the target SFEE system. It determines the artifact
			action by checking if the artifact has an identity mapping already.
			If the identity mapping does not exist then the EntityService marks this artifact
			action as create otherwise update. Please refer the SynchronizationStatusAndIdentityMappingTableUpdater
			component.
		</description>
		<property name="entityServiceReader" ref="SynchronizationStatusDatabaseReader" />
	</bean>

	<bean id="JdbcConnectionReadQC2SFEE"
		class="org.openadaptor.auxil.connector.jdbc.JDBCConnection">
		<description>
			This defines jdbc connection that will be used by the
			SimplePollingReaderQC2SFEE
		</description>
		<property name="driver" value="${ccf.db.driver}" />
		<property name="url" value="${ccf.db.url}" />
		<property name="username" value="${ccf.db.username}" />
		<property name="password" value="${ccf.db.password}" />
	</bean>
	<bean id="JdbcConnectionReadSFEE2QC"
		class="org.openadaptor.auxil.connector.jdbc.JDBCConnection">
		<description>
			This defines jdbc connection that will be used by the
			SimplePollingReaderSFEE2QC
		</description>
		<property name="driver" value="${ccf.db.driver}" />
		<property name="url" value="${ccf.db.url}" />
		<property name="username" value="${ccf.db.username}" />
		<property name="password" value="${ccf.db.password}" />
	</bean>
	<bean id="SynchronizationStatusAndIdentityMappingTableUpdater"
		class="com.collabnet.ccf.core.config.MappingDBUpdater">
		<description>
			This component is responsible for creating the identity mapping for newly created
			artifacts in the target system. It also updates the synchronization status for a 
			particular repository. For SFEE systems the synchronization info is the last
			modified time of the last shipped artifact.
			If the EntityService determines the artifact action as create (that is this artifact
			is a new artifact in the source system and doesn't have its identity mapping filled
			in the Sync info tables) then the writer component creates the artifact in the target
			system and populates the target artifact id in the Generic Artifact XML.
			The SynchronizationStatusAndIdentityMappingTableUpdater then takes the target artifact
			id and creates an identity mapping entry for the source and target artifact ids.
		</description>
		<property name="mappingWriter" ref="MappingWriter"></property>
		<property name="entityServiceReader" ref="SynchronizationStatusDatabaseReader" />
		<property name="entityServiceWriteConnector"
			ref="SynchronizationStatusDatabaseWriter">
		</property>
	</bean>
	<bean id="ResultSetConverter"
		class="org.openadaptor.auxil.connector.jdbc.reader.xml.ResultSetToXMLConverter">
		<property name="convertToString" value="false" />
		<property name="rootElement" value="EmptySyncInf" />
	</bean>
	
	<bean id="SynchronizationStatusDatabaseWriter"
		class="org.openadaptor.auxil.connector.jdbc.writer.JDBCWriteConnector">
		<description>
			This component updates the synchronization status for the current artifact.
		</description>
		<property name="writer" ref="EntityServiceMapTableWriter"></property>
		<property name="jdbcConnection"
			ref="JDBCConnection">
		</property>
	</bean>
	<bean id="QCTransformer"
		class="com.collabnet.ccf.core.transformer.XsltProcessor">
		<description>The xsltDir specifies the directory in which the xsl files are contained. The naming conventions
		for the xsl files need to be followed. 
		Name of an xsl file should be: sourceSystem+sourceRepository+targetSystem+targetRepository.xsl 
		</description>
		<!-- <property name="xsltFile" value="${ccf.sfee2qc.xsltFile}" />  -->
		<property name="xsltDir" value="${ccf.xsltDir}" />
	</bean>
	<bean id="QCEntityService"
		class="com.collabnet.ccf.core.EntityService">
		<description>
			This component is responsible for determining if the current artifact that is being
			shipped is to be created or updated in the target SFEE system. It determines the artifact
			action by checking if the artifact has an identity mapping already.
			If the identity mapping does not exist then the EntityService marks this artifact
			action as create otherwise update. Please refer the SynchronizationStatusAndIdentityMappingTableUpdater
			component.
		</description>
		<property name="entityServiceReader" ref="SynchronizationStatusDatabaseReader" />
	</bean>
	<bean id="QCWriter" class="com.collabnet.ccf.pi.qc.v90.QCWriter">
		<description>
			This QCWriter will write the data contained in the incoming
			document to QC.
		</description>
		<property name="serverUrl" value="${qc.system.1.url}" />
		<property name="userName" value="${qc.system.1.username}" />
		<property name="password" value="${qc.system.1.password}" />
		<property name="connectionManager" ref="QCConnectionManager"></property>
	</bean>
	<bean id="EntityServiceJdbcConnection"
		class="org.openadaptor.auxil.connector.jdbc.JDBCConnection">
		<description>
			This defines jdbc connection that will be used by the
			SimplePollingReaderSFEE2QC
		</description>
		<property name="driver" value="${ccf.db.driver}" />
		<property name="url" value="${ccf.db.url}" />
		<property name="username" value="${ccf.db.username}" />
		<property name="password" value="${ccf.db.password}" />
	</bean>
	<bean id="EntityServiceWriter"
		class="org.openadaptor.auxil.connector.jdbc.writer.JDBCWriteConnector">
		<property name="writer" ref="EntityServiceMapTableWriter"></property>
		<property name="jdbcConnection"
			ref="EntityServiceJdbcConnection">
		</property>
	</bean>
	<bean id="EntityServiceMapTableWriter"
		class="org.openadaptor.auxil.connector.jdbc.writer.MapTableWriter">
		<description>
			This is the writer object that writes the artifact mapping
			information into the database table.
		</description>
		<property name="tableName" value="IDENTITY_MAPPING"></property>
		<property name="outputColumns">
			<list>
				<value>SOURCE_SYSTEM_ID</value>
				<value>SOURCE_REPOSITORY_ID</value>
				<value>TARGET_SYSTEM_ID</value>
				<value>TARGET_REPOSITORY_ID</value>
				<value>SOURCE_ARTIFACT_ID</value>
				<value>TARGET_ARTIFACT_ID</value>
				<value>LAST_READ_TIME</value>
				<value>VERSION</value>
			</list>
		</property>
	</bean>
	<bean id="SynchronizationStatusDatabaseReader"
		class="org.openadaptor.auxil.connector.jdbc.reader.JDBCReadConnector">
		<description>
			This database reader component reads the target artifact id from the databse
			for a given source artifact id and the target repository and system information.
		</description>
		<property name="jdbcConnection"
			ref="JDBCConnection" />
		<!-- batch size of 0 or less means process all rows in one message batch. -->
		<!-- batch size of one means process one row per message and so on -->
		<property name="batchSize" value="0" />
		<property name="sql">
			<value>${ccf.targetartifactid.sql}</value>
		</property>
	</bean>
	<bean id="JDBCConnection"
		class="org.openadaptor.auxil.connector.jdbc.JDBCConnection">
		<description>
			This defines a jdbc connection that will be used by the
			SynchronizationStatusDatabaseReader, IdentityMappingDatabaseReader and
			SynchronizationStatusDatabaseWriter
		</description>
		<property name="driver" value="${ccf.db.driver}" />
		<property name="url" value="${ccf.db.url}" />
		<property name="username" value="${ccf.db.username}" />
		<property name="password" value="${ccf.db.password}" />
	</bean>
	<bean id="MappingWriter"
		class="org.openadaptor.auxil.connector.jdbc.writer.JDBCWriteConnector">
		<property name="writer" ref="IdentityMappingDatabaseUpdater"></property>
		<property name="jdbcConnection"
			ref="JDBCConnection">
		</property>
	</bean>
	<bean id="IdentityMappingDatabaseUpdater"
		class="com.collabnet.ccf.core.db.MapTableUpdater">
		<description>
			This is the writer object that writes the artifact mapping
			information into the database table.
		</description>
		<property name="tableName" value="SYNCHRONIZATION_STATUS"></property>
		<property name="sql" value="${ccf.mapping.updater.sql}"></property>
		<property name="outputColumns">
			<list>
				<value>LAST_READ_TIME</value>
				<value>VERSION</value>
				<value>TRANSACTION_ID</value>
				<value>SOURCE_SYSTEM_ID</value>
				<value>SOURCE_REPOSITORY_ID</value>
				<value>TARGET_SYSTEM_ID</value>
				<value>TARGET_REPOSITORY_ID</value>
			</list>
		</property>
	</bean>
	<bean id="ExceptionHandler" class="com.collabnet.ccf.core.hospital.Ambulance">
  		<property name="hospitalFileName" value="C:/hospital.txt"/>
  	</bean>
</beans>
